{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/node_modules/@bitmatrix/int53/common.js","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/node_modules/@bitmatrix/int53/index.js","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/node_modules/@bitmatrix/int53/read.js","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/node_modules/@bitmatrix/int53/write.js","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/src/errors.ts","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/src/lib/CAllBuffer.ts","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/src/lib/CArray.ts","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/src/lib/CBuffer.ts","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/src/lib/CNumber.ts","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/src/lib/CObject.ts","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/src/lib/CString.ts","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/src/lib/CVarArray.ts","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/src/lib/CVarBuffer.ts","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/src/lib/CVarString.ts","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/src/lib/CVarUIntBitcoin.ts","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/src/lib/index.ts","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/src/models/NumberTypes.ts","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/src/models/index.ts","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/src/util.ts","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/webpack/bootstrap","webpack://@bitmatrix/bitcodec-bitcoin/@bitmatrix/bitcodec/src/index.ts","webpack://@bitmatrix/bitcodec-bitcoin/./src/converter.ts","webpack://@bitmatrix/bitcodec-bitcoin/./src/index.ts","webpack://@bitmatrix/bitcodec-bitcoin/./src/lib/TxCodec.ts","webpack://@bitmatrix/bitcodec-bitcoin/./src/lib/WitnessLocktimeCodec.ts","webpack://@bitmatrix/bitcodec-bitcoin/./src/lib/codecs.ts","webpack://@bitmatrix/bitcodec-bitcoin/webpack/bootstrap","webpack://@bitmatrix/bitcodec-bitcoin/webpack/startup"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toDouble = exports.intHighLow = exports.uintHighLow = exports.onesComplement = exports.assert = exports.Int53Type = void 0;\nconst MAX_UINT32 = 0x00000000ffffffff;\nconst MAX_INT53 = 0x001fffffffffffff;\nvar Int53Type;\n(function (Int53Type) {\n    Int53Type[\"Int64BE\"] = \"Int64BE\";\n    Int53Type[\"Int64LE\"] = \"Int64LE\";\n    Int53Type[\"UInt64BE\"] = \"UInt64BE\";\n    Int53Type[\"UInt64LE\"] = \"UInt64LE\";\n})(Int53Type = exports.Int53Type || (exports.Int53Type = {}));\nconst assert = (test, message) => {\n    if (!test)\n        throw new Error(message);\n};\nexports.assert = assert;\nconst onesComplement = (number) => {\n    number = ~number;\n    if (number < 0) {\n        number = (number & 0x7fffffff) + 0x80000000;\n    }\n    return number;\n};\nexports.onesComplement = onesComplement;\nconst uintHighLow = (number) => {\n    (0, exports.assert)(number > -1 && number <= MAX_INT53, \"number out of range\");\n    (0, exports.assert)(Math.floor(number) === number, \"number must be an integer\");\n    var high = 0;\n    var signbit = number & 0xffffffff;\n    var low = signbit < 0 ? (number & 0x7fffffff) + 0x80000000 : signbit;\n    if (number > MAX_UINT32) {\n        high = (number - low) / (MAX_UINT32 + 1);\n    }\n    return [high, low];\n};\nexports.uintHighLow = uintHighLow;\nconst intHighLow = (number) => {\n    if (number > -1) {\n        return (0, exports.uintHighLow)(number);\n    }\n    var hl = (0, exports.uintHighLow)(-number);\n    var high = (0, exports.onesComplement)(hl[0]);\n    var low = (0, exports.onesComplement)(hl[1]);\n    if (low === MAX_UINT32) {\n        high += 1;\n        low = 0;\n    }\n    else {\n        low += 1;\n    }\n    return [high, low];\n};\nexports.intHighLow = intHighLow;\nconst toDouble = (high, low, signed) => {\n    if (signed && (high & 0x80000000) !== 0) {\n        high = (0, exports.onesComplement)(high);\n        low = (0, exports.onesComplement)(low);\n        (0, exports.assert)(high < 0x00200000, \"number too small\");\n        return -(high * (MAX_UINT32 + 1) + low + 1);\n    }\n    else {\n        //positive\n        (0, exports.assert)(high < 0x00200000, \"number too large\");\n        return high * (MAX_UINT32 + 1) + low;\n    }\n};\nexports.toDouble = toDouble;\n//# sourceMappingURL=common.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.readInt53 = exports.writeInt53 = exports.Int53Type = void 0;\nvar common_1 = require(\"./common\");\nObject.defineProperty(exports, \"Int53Type\", { enumerable: true, get: function () { return common_1.Int53Type; } });\nvar write_1 = require(\"./write\");\nObject.defineProperty(exports, \"writeInt53\", { enumerable: true, get: function () { return write_1.write; } });\nvar read_1 = require(\"./read\");\nObject.defineProperty(exports, \"readInt53\", { enumerable: true, get: function () { return read_1.read; } });\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.read = void 0;\nconst common_1 = require(\"./common\");\nconst read = (int53Type, buffer, offset = 0) => {\n    const BE = int53Type.endsWith(\"BE\");\n    const [high, low] = BE ? [buffer.readUInt32BE(offset), buffer.readUInt32BE(offset + 4)] : [buffer.readUInt32LE(offset + 4), buffer.readUInt32LE(offset)];\n    const signed = int53Type.startsWith(\"Int\");\n    return (0, common_1.toDouble)(high, low, signed);\n};\nexports.read = read;\n//# sourceMappingURL=read.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.write = void 0;\nconst common_1 = require(\"./common\");\nconst write = (int53Type, number, buffer, offset = 0) => {\n    const signed = int53Type.startsWith(\"Int\");\n    const hl = signed ? (0, common_1.intHighLow)(number) : (0, common_1.uintHighLow)(number);\n    const BE = int53Type.endsWith(\"BE\");\n    if (BE) {\n        buffer.writeUInt32BE(hl[0], offset);\n        buffer.writeUInt32BE(hl[1], offset + 4);\n    }\n    else {\n        buffer.writeUInt32LE(hl[1], offset);\n        buffer.writeUInt32LE(hl[0], offset + 4);\n    }\n};\nexports.write = write;\n//# sourceMappingURL=write.js.map","export const checkLength = (codecName: string, valueLength: number, codecLength: number) => {\n  if (valueLength !== codecLength) throw new RangeError(`${codecName} Codec: value length is not equal codec length. valueLength = ${valueLength}, codecLength = ${codecLength}.`);\n};\n\nexport const checkBufferLengthForEncode = (codecName: string, buffer: Buffer, offset: number, codecLength: number) => {\n  if (buffer.length - offset < codecLength)\n    throw new RangeError(`${codecName} Codec: buffer is too small. buffer.length = ${buffer.length}, offset = ${offset}, codecLength = ${codecLength}.`);\n};\n\nexport const checkBufferLengthForDecode = (codecName: string, offset: number, end: number, codecLength: number) => {\n  if (end - offset < codecLength) throw new RangeError(`${codecName} Codec: not enough data for decode. offset = ${offset}, end = ${end}, codecLength = ${codecLength}.`);\n};\n\nexport const checkDefined = (codecName: string, value?: any, type: \"object\" | \"array\" | \"buffer\" | \"number\" | \"string\" = \"object\") => {\n  if (value === undefined) throw new TypeError(`${codecName} Codec: value must be ${type} but got undefined.`);\n  if (type === \"buffer\" && !Buffer.isBuffer(value)) throw new TypeError(`${codecName} Codec: value must be ${type} but got undefined.`);\n};\n\nexport const typeError = (codecName: string, message: string) => {\n  throw new TypeError(`${codecName} Codec: ${message}.`);\n};\n\nexport const rangeError = (codecName: string, message: string) => {\n  throw new RangeError(`${codecName} Codec: ${message}.`);\n};\n","import { IBitcodec } from \"../models/IBitcodec\";\n\nexport class CAllBuffer implements IBitcodec<Buffer> {\n  private length: number;\n  encodingLength = (buffer?: Buffer): number => buffer?.length || this.length;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor() {\n    this.length = 0;\n    this.encodeBytes = 0;\n    this.decodeBytes = 0;\n  }\n\n  encode = (value: Buffer, buffer?: Buffer, offset = 0): Buffer => {\n    this.length = value.length;\n    this.encodeBytes = value.length;\n    this.decodeBytes = value.length;\n    if (!Buffer.isBuffer(value)) throw new TypeError(\"value must be a Buffer instance\"); // for CArray encode iter\n    if (!buffer) return Buffer.from(value);\n    if (offset + this.length > buffer.length) throw new RangeError(\"destination buffer is too small\");\n    value.copy(buffer, offset);\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): Buffer => {\n    this.length = buffer.length;\n    this.encodeBytes = buffer.length;\n    this.decodeBytes = buffer.length;\n    if (!end) end = buffer.length;\n    this.length = buffer.length - offset;\n    if (offset + this.length > end) throw new RangeError(\"not enough data for decode\");\n    return Buffer.from(buffer.slice(offset, offset + this.length));\n  };\n}\n","import * as util from \"../util\";\nimport { IBitcodec } from \"../models/IBitcodec\";\nimport { checkDefined, checkLength } from \"../errors\";\n\nexport class CArray implements IBitcodec<any[]> {\n  private codecName = \"CArray\";\n  private length: number;\n  private anyCodec: IBitcodec<any>;\n\n  private calcLength = (items: any[]) => {\n    return util.calcAllLength(items, this.anyCodec.encodingLength);\n  };\n\n  encodingLength = (array?: any[]): number => {\n    checkDefined(this.codecName, array, \"array\");\n    if (array === undefined) return 0; // never\n    checkLength(this.codecName, array.length, this.length);\n    return this.calcLength(array);\n  };\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(length: number, anyCodec: IBitcodec<any>) {\n    this.length = length;\n    this.anyCodec = anyCodec;\n    this.encodeBytes = length;\n    this.decodeBytes = length;\n  }\n\n  encode = (value: any[], buffer?: Buffer, offset = 0): Buffer => {\n    checkLength(this.codecName, value.length, this.length);\n\n    if (!buffer) buffer = Buffer.allocUnsafe(this.calcLength(value));\n    const typeEncode = this.anyCodec.encode;\n    const typeEncodeBytes = this.anyCodec.encodeBytes;\n\n    /* this.encodeBytes =\n      value.reduce((previusValue, currentItem, _) => {\n        this.anyCodec.encode(currentItem, buffer, previusValue);\n        const newAnyCodecEncodeBytes = this.anyCodec.encodeBytes;\n        return previusValue + newAnyCodecEncodeBytes;\n      }, offset) - offset; */\n\n    this.encodeBytes =\n      util.calcAllLength(\n        value,\n        function (item, index, loffset) {\n          typeEncode(item, buffer, loffset);\n          return typeEncodeBytes;\n        },\n        offset\n      ) - offset;\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): any[] => {\n    if (!offset) offset = 0;\n    const items = new Array(this.length);\n\n    const typeDecode = this.anyCodec.decode;\n    const typeDecodeBytes = this.anyCodec.decodeBytes;\n\n    /* this.decodeBytes =\n      items.reduce((previusValue, currentItem, currentIndex) => {\n        items[currentIndex] = this.anyCodec.decode(buffer, previusValue, end);\n        const newAnyCodecDecodeBytes = this.anyCodec.decodeBytes;\n        return previusValue + newAnyCodecDecodeBytes;\n      }, offset + offset) - offset; */\n\n    this.decodeBytes =\n      util.calcAllLength(\n        items,\n        function (item, index, loffset) {\n          items[index || 0] = typeDecode(buffer, loffset, end);\n          return typeDecodeBytes;\n        },\n        offset\n      ) - offset;\n    return items;\n  };\n}\n","import { checkLength, checkBufferLengthForEncode, checkBufferLengthForDecode, checkDefined } from \"../errors\";\nimport { IBitcodec } from \"../models/IBitcodec\";\n\nexport class CBuffer implements IBitcodec<Buffer> {\n  private codecName = \"Buffer\";\n  private length: number;\n  encodingLength = (): number => this.length;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(length: number) {\n    this.length = length;\n    this.encodeBytes = length;\n    this.decodeBytes = length;\n  }\n\n  encode = (value: Buffer, buffer?: Buffer, offset = 0): Buffer => {\n    checkDefined(this.codecName, value, \"buffer\");\n    checkLength(this.codecName, value.length, this.length);\n\n    if (!buffer) return Buffer.from(value);\n    checkBufferLengthForEncode(this.codecName, buffer, offset, this.length);\n\n    value.copy(buffer, offset);\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): Buffer => {\n    if (!end) end = buffer.length;\n    checkBufferLengthForDecode(this.codecName, offset, end, this.length);\n\n    return Buffer.from(buffer.slice(offset, offset + this.length));\n  };\n}\n","import { Int53Type, readInt53, writeInt53 } from \"@bitmatrix/int53\";\nimport { IBitcodec } from \"../models/IBitcodec\";\nimport { NumberTypes } from \"../models/NumberTypes\";\n\nexport class CNumber implements IBitcodec<number> {\n  private length: number;\n  private write: (buffer: Buffer, value: number, offset?: number) => void;\n  private read: (buffer: Buffer, offset?: number | undefined) => number;\n\n  encodingLength = (number?: number): number => this.length;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(numberType: NumberTypes, length: number) {\n    this.length = length;\n    this.encodeBytes = length;\n    this.decodeBytes = length;\n\n    if (Buffer.prototype[\"write\" + numberType]) {\n      this.write = (buffer: Buffer, value: number, offset?: number) => {\n        return (buffer as any)[\"write\" + numberType](value, offset);\n      };\n    } else {\n      this.write = (buffer: Buffer, value: number, offset?: number) => {\n        return writeInt53(numberType as unknown as Int53Type, value, buffer, offset);\n      };\n    }\n\n    if (Buffer.prototype[\"read\" + numberType]) {\n      this.read = (buffer: Buffer, offset?: number) => {\n        return (buffer as any)[\"read\" + numberType](offset);\n      };\n    } else {\n      this.read = (buffer: Buffer, offset?: number) => {\n        return readInt53(numberType as unknown as Int53Type, buffer, offset);\n      };\n    }\n  }\n\n  encode = (value: number, buffer?: Buffer, offset = 0): Buffer => {\n    buffer = buffer || Buffer.allocUnsafe(this.length);\n    this.write(buffer, value, offset);\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): number => {\n    if (!end) return this.read(buffer, offset);\n    return this.read(buffer.slice(offset, end), 0);\n  };\n}\n","import { checkBufferLengthForEncode, checkDefined } from \"../errors\";\nimport { BitcodecItem } from \"../models/BitcodecItem\";\nimport { IBitcodec } from \"../models/IBitcodec\";\n\nexport class CObject implements IBitcodec<object> {\n  private codecName = \"CObject\";\n  private items: { name: string; type: IBitcodec<any> }[];\n\n  encodeBytes: number;\n  decodeBytes: number;\n  encodingLength: (t?: object) => number;\n\n  constructor(items: BitcodecItem[]) {\n    this.items = items.map((item: BitcodecItem) => (Array.isArray(item) ? { name: item[0], type: item[1] } : item));\n\n    this.encodeBytes = 0;\n    this.decodeBytes = 0;\n\n    this.encodingLength = (o?: object): number => {\n      checkDefined(this.codecName, o, \"object\");\n      if (o === undefined) return 0; // never\n\n      return this.items.reduce((previousValue: number, currentValue: { name: string; type: IBitcodec<any> }) => {\n        const value = (o as any)[currentValue.name];\n        return previousValue + currentValue.type.encodingLength(value);\n      }, 0);\n    };\n  }\n\n  encode = (object: object, buffer?: Buffer, offset = 0): Buffer => {\n    const start = offset;\n    const bytes = this.encodingLength(object);\n    if (buffer === undefined) buffer = Buffer.allocUnsafe(bytes);\n    else checkBufferLengthForEncode(this.codecName, buffer, offset, bytes);\n\n    this.items.forEach((item) => {\n      const value = (object as any)[item.name];\n      item.type.encode(value, buffer, offset);\n      offset += item.type.encodeBytes;\n    });\n    this.encodeBytes = offset - start;\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset: number = 0, end?: number | undefined): object => {\n    let result = {};\n    const start = offset;\n\n    this.items.forEach((item) => {\n      const value = item.type.decode(buffer, offset, end);\n      offset += item.type.decodeBytes;\n      (result as any)[item.name] = value;\n    });\n    this.decodeBytes = offset - start;\n\n    return result;\n  };\n}\n","import { checkBufferLengthForDecode, checkBufferLengthForEncode, checkLength } from \"../errors\";\nimport { EncodingType } from \"../models/EncodingType\";\nimport { IBitcodec } from \"../models/IBitcodec\";\nimport { CBuffer } from \"./CBuffer\";\n\n// https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_string\nexport class CString implements IBitcodec<string> {\n  private codecName = \"String\";\n  private length: number;\n  private bufferCodec: IBitcodec<Buffer>;\n  private encodingType: EncodingType;\n\n  encodingLength = (value?: string) => this.length;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(length: number, encodingType: EncodingType = \"utf8\") {\n    this.length = length;\n    this.encodingType = encodingType;\n    this.bufferCodec = new CBuffer(this.length);\n\n    this.encodeBytes = length;\n    this.decodeBytes = length;\n  }\n\n  encode = (value: string, buffer?: Buffer, offset = 0): Buffer => {\n    checkLength(this.codecName, Buffer.byteLength(value, this.encodingType), this.length);\n\n    if (!buffer) return Buffer.from(value, this.encodingType);\n    checkBufferLengthForEncode(this.codecName, buffer, offset, this.length);\n\n    buffer.write(value, offset, this.length, this.encodingType);\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): string => {\n    checkBufferLengthForDecode(this.codecName, offset, end || buffer.length, this.length);\n    return this.bufferCodec.decode(buffer, offset, end).toString(this.encodingType);\n  };\n}\n","import * as util from \"../util\";\nimport { IBitcodec } from \"../models/IBitcodec\";\nimport { checkDefined } from \"../errors\";\n\nexport class CVarArray implements IBitcodec<any[]> {\n  private codecName = \"CVarArray\";\n  private length: number = -1;\n  private lengthCodec: IBitcodec<any>;\n  private itemCodec: IBitcodec<any>;\n\n  private calcLength = (items: any[]) => {\n    return util.calcAllLength(items, this.itemCodec.encodingLength, this.lengthCodec.encodingLength(items.length));\n  };\n\n  encodingLength = (array?: any[]): number => {\n    checkDefined(this.codecName, array, \"array\");\n    if (array === undefined) return 0; // never\n    return this.calcLength(array);\n  };\n\n  encodeBytes: number = 0;\n  decodeBytes: number = 0;\n\n  constructor(lengthCodec: IBitcodec<any>, itemCodec: IBitcodec<any>) {\n    this.lengthCodec = lengthCodec;\n    this.itemCodec = itemCodec;\n  }\n\n  encode = (value: any[], buffer?: Buffer, offset = 0): Buffer => {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.calcLength(value));\n\n    this.lengthCodec.encode(value.length, buffer, offset);\n\n    /* this.encodeBytes =\n      value.reduce((previusValue, currentItem, _) => {\n        this.anyCodec.encode(currentItem, buffer, previusValue);\n        const newAnyCodecEncodeBytes = this.anyCodec.encodeBytes;\n        return previusValue + newAnyCodecEncodeBytes;\n      }, this.lengthType.encodeBytes + offset) - offset; */\n\n    this.encodeBytes =\n      util.calcAllLength(\n        value,\n        (item, index, loffset) => {\n          this.itemCodec.encode(item, buffer, loffset);\n          return this.itemCodec.encodeBytes;\n        },\n        this.lengthCodec.encodeBytes + offset\n      ) - offset;\n\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): any[] => {\n    if (!offset) offset = 0;\n    const items = new Array(this.lengthCodec.decode(buffer, offset, end));\n\n    /* this.decodeBytes =\n      items.reduce((previusValue, currentItem, currentIndex) => {\n        items[currentIndex] = this.anyCodec.decode(buffer, previusValue, end);\n        const newAnyCodecDecodeBytes = this.anyCodec.decodeBytes;\n        return previusValue + newAnyCodecDecodeBytes;\n      }, this.lengthType.decodeBytes + offset) - offset; */\n\n    this.decodeBytes =\n      util.calcAllLength(\n        items,\n        (item, index, loffset) => {\n          items[index || 0] = this.itemCodec.decode(buffer, loffset, end);\n          return this.itemCodec.decodeBytes;\n        },\n        this.lengthCodec.decodeBytes + offset\n      ) - offset;\n    return items;\n  };\n}\n","import { checkBufferLengthForDecode, checkBufferLengthForEncode, checkDefined } from \"../errors\";\nimport { IBitcodec } from \"../models/IBitcodec\";\nimport { CNumber } from \"./CNumber\";\nimport { CVarUIntBitcoin } from \"./CVarUIntBitcoin\";\n\nexport class CVarBuffer implements IBitcodec<any> {\n  private codecName = \"VarBuffer\";\n  private anyCodec: IBitcodec<any>;\n  encodingLength: (buffer?: Buffer) => number;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(anyCodec: IBitcodec<CNumber | CVarUIntBitcoin>) {\n    this.anyCodec = anyCodec;\n    this.encodeBytes = 0;\n    this.decodeBytes = 0;\n\n    this.encodingLength = (buffer?: Buffer) => {\n      checkDefined(this.codecName, buffer, \"buffer\"); // for CArray encode iter\n      if (buffer !== undefined) return this.anyCodec.encodingLength(buffer.length) + buffer.length;\n      return 0; // never\n    };\n  }\n\n  encode = (value: Buffer, buffer?: Buffer, offset = 0): Buffer => {\n    const bytes = this.encodingLength(value);\n    if (!buffer) buffer = Buffer.allocUnsafe(bytes);\n    else checkBufferLengthForEncode(this.codecName, buffer, offset, bytes);\n\n    this.anyCodec.encode(value.length, buffer, offset);\n    offset += this.anyCodec.encodeBytes;\n\n    value.copy(buffer, offset);\n    this.encodeBytes = bytes;\n\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): Buffer => {\n    if (end === undefined) end = buffer.length;\n    const start = offset;\n    const length = this.anyCodec.decode(buffer, offset, end);\n    offset += this.anyCodec.decodeBytes;\n    checkBufferLengthForDecode(this.codecName, offset, end, length);\n\n    this.decodeBytes = offset + length - start;\n    return Buffer.from(buffer.slice(offset, offset + length));\n  };\n}\n","import { checkDefined } from \"../errors\";\nimport { EncodingType } from \"../models/EncodingType\";\nimport { IBitcodec } from \"../models/IBitcodec\";\nimport { CVarBuffer } from \"./CVarBuffer\";\n\nexport class CVarString implements IBitcodec<string> {\n  private codecName = \"CVarString\";\n  private anyCodec: IBitcodec<any>;\n  private encodingType: EncodingType;\n  private varBufferCodec: CVarBuffer;\n  encodingLength: (value?: string) => number;\n\n  encodeBytes: number;\n  decodeBytes: number;\n\n  constructor(anyCodec: IBitcodec<any>, encodingType: EncodingType = \"utf8\") {\n    this.anyCodec = anyCodec;\n    this.encodingType = encodingType;\n    this.varBufferCodec = new CVarBuffer(anyCodec);\n\n    this.encodeBytes = 0;\n    this.decodeBytes = 0;\n\n    this.encodingLength = (value?: string) => {\n      checkDefined(this.codecName, value, \"string\");\n      if (value === undefined) return 0; // never;\n\n      const valueLength = Buffer.byteLength(value, this.encodingType);\n      return this.anyCodec.encodingLength(value.length) + valueLength;\n    };\n  }\n\n  encode = (value: string, buffer?: Buffer, offset = 0): Buffer => {\n    const valueLength = Buffer.byteLength(value, this.encodingType);\n    const bytes = this.anyCodec.encodingLength(value.length) + valueLength;\n\n    if (!buffer) buffer = Buffer.allocUnsafe(bytes);\n    if (offset + bytes > buffer.length) throw new RangeError(\"destination buffer is too small\");\n\n    this.anyCodec.encode(valueLength, buffer, offset);\n    offset += this.anyCodec.encodeBytes;\n    buffer.write(value, offset, valueLength, this.encodingType);\n\n    this.encodeBytes = bytes;\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): string => {\n    const str = this.varBufferCodec.decode(buffer, offset, end).toString(this.encodingType);\n    this.decodeBytes = this.varBufferCodec.decodeBytes;\n    return str;\n  };\n}\n","import { checkDefined, rangeError, typeError } from \"../errors\";\nimport { IBitcodec } from \"../models/IBitcodec\";\n\n// https://en.bitcoin.it/wiki/Protocol_documentation#Variable_length_integer\nexport class CVarUIntBitcoin implements IBitcodec<number> {\n  private codecName = \"VarUIntBitcoin\";\n  private MAX_SAFE_INTEGER: number = 9007199254740991;\n\n  private checkUInt53 = (n: number) => {\n    if (n < 0 || n > this.MAX_SAFE_INTEGER) rangeError(this.codecName, `out of range value. min = 0, max = ${this.MAX_SAFE_INTEGER}, value = ${n}`);\n    if (n % 1 !== 0) typeError(this.codecName, `value is not an integer. value = ${n}`);\n  };\n\n  encodeBytes: number;\n  decodeBytes: number;\n  encodingLength: (number?: number) => number;\n\n  constructor() {\n    this.encodeBytes = 0;\n    this.decodeBytes = 0;\n    this.encodingLength = (number?: number) => {\n      checkDefined(this.codecName, number, \"number\");\n      if (number === undefined) return 0; // never\n\n      this.checkUInt53(number);\n      return number < 0xfd ? 1 : number <= 0xffff ? 3 : number <= 0xffffffff ? 5 : 9;\n    };\n  }\n\n  encode = (value: number, buffer?: Buffer, offset: number = 0): Buffer => {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.encodingLength(value));\n\n    // 8 bit\n    if (value < 0xfd) {\n      buffer.writeUInt8(value, offset);\n      this.encodeBytes = 1;\n\n      // 16 bit\n    } else if (value <= 0xffff) {\n      buffer.writeUInt8(0xfd, offset);\n      buffer.writeUInt16LE(value, offset + 1);\n      this.encodeBytes = 3;\n\n      // 32 bit\n    } else if (value <= 0xffffffff) {\n      buffer.writeUInt8(0xfe, offset);\n      buffer.writeUInt32LE(value, offset + 1);\n      this.encodeBytes = 5;\n\n      // 64 bit\n    } else {\n      buffer.writeUInt8(0xff, offset);\n      buffer.writeUInt32LE(value >>> 0, offset + 1);\n      buffer.writeUInt32LE((value / 0x100000000) | 0, offset + 5);\n      this.encodeBytes = 9;\n    }\n\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset: number = 0, end?: number): number => {\n    const first = buffer.readUInt8(offset);\n\n    // 8 bit\n    if (first < 0xfd) {\n      this.decodeBytes = 1;\n      return first;\n\n      // 16 bit\n    } else if (first === 0xfd) {\n      this.decodeBytes = 3;\n      return buffer.readUInt16LE(offset + 1);\n\n      // 32 bit\n    } else if (first === 0xfe) {\n      this.decodeBytes = 5;\n      return buffer.readUInt32LE(offset + 1);\n\n      // 64 bit\n    } else {\n      this.decodeBytes = 9;\n      var lo = buffer.readUInt32LE(offset + 1);\n      var hi = buffer.readUInt32LE(offset + 5);\n      var number = hi * 0x0100000000 + lo;\n      this.checkUInt53(number);\n\n      return number;\n    }\n  };\n}\n","export { CAllBuffer } from \"./CAllBuffer\";\nexport { CArray } from \"./CArray\";\nexport { CBuffer } from \"./CBuffer\";\nexport { CNumber } from \"./CNumber\";\nexport { CObject } from \"./CObject\";\nexport { CString } from \"./CString\";\nexport { CVarArray } from \"./CVarArray\";\nexport { CVarBuffer } from \"./CVarBuffer\";\nexport { CVarString } from \"./CVarString\";\nexport { CVarUIntBitcoin } from \"./CVarUIntBitcoin\";\n","export enum NumberTypes {\n  Byte = \"UInt8\",\n  Int8 = \"Int8\",\n  UInt8 = \"UInt8\",\n  Int16BE = \"Int16BE\",\n  Int16LE = \"Int16LE\",\n  UInt16BE = \"UInt16BE\",\n  UInt16LE = \"UInt16LE\",\n  Int32BE = \"Int32BE\",\n  Int32LE = \"Int32LE\",\n  UInt32BE = \"UInt32BE\",\n  UInt32LE = \"UInt32LE\",\n  Int64BE = \"Int64BE\",\n  Int64LE = \"Int64LE\",\n  UInt64BE = \"UInt64BE\",\n  UInt64LE = \"UInt64LE\",\n  FloatBE = \"FloatBE\",\n  FloatLE = \"FloatLE\",\n  DoubleBE = \"DoubleBE\",\n  DoubleLE = \"DoubleLE\",\n}\n","export { BitcodecItem } from \"./BitcodecItem\";\nexport { EncodingType } from \"./EncodingType\";\nexport { IBitcodec } from \"./IBitcodec\";\nexport { NumberTypes } from \"./NumberTypes\";\n","export const calcAllLength = <T>(items: T[], calcLength: (item?: T, itemIndex?: number, itemOffset?: number) => number, allOffset: number = 0) => {\n  let lOffset = allOffset;\n  for (let i = 0; i < items.length; i++) lOffset += calcLength(items[i], i, lOffset);\n  return lOffset;\n\n  /* return items.reduce((previusValue, currentItem, currentIndex) => {\n    return previusValue + iter(items[currentIndex], currentIndex, previusValue);\n  }, acc); */\n};\n\nconst copy = (obj: any): any => {\n  if (Buffer.isBuffer(obj)) return obj.slice();\n  if (Array.isArray(obj)) return obj.map(copy);\n  if (typeof obj === \"object\") {\n    const newObj: any = {};\n    for (let k in obj) {\n      newObj[k] = copy(obj[k]);\n    }\n    return newObj;\n  }\n\n  if (typeof obj === \"function\") throw \"unsupported copy!\";\n  return obj;\n};\n\nfunction isHex(s: string) {\n  return s.length % 2 === 0 && /^[0-9a-f]*$/.test(s.toLowerCase());\n}\n\nexport function hex2buffer(obj: any) {\n  if (Buffer.isBuffer(obj)) return copy(obj);\n  else if (typeof obj === \"string\" && isHex(obj)) return Buffer.from(obj, \"hex\");\n  else if (typeof obj === \"object\") {\n    const newObj = copy(obj);\n    for (var k in newObj) {\n      newObj[k] = hex2buffer(newObj[k]);\n    }\n    return newObj;\n  } else if (Array.isArray(obj)) {\n    return copy(obj).map(hex2buffer);\n  }\n\n  return obj;\n}\n\nexport function buffer2hex(obj: any) {\n  if (Buffer.isBuffer(obj)) {\n    const newBuffer = copy(obj);\n    return newBuffer.toString(\"hex\");\n  } else if (Array.isArray(obj)) {\n    let newObj = copy(obj);\n    newObj = newObj.map(buffer2hex);\n    return newObj;\n  } else if (typeof obj === \"object\") {\n    const newObj = copy(obj);\n    for (var k in newObj) {\n      newObj[k] = buffer2hex(newObj[k]);\n    }\n    return newObj;\n  }\n\n  return obj;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import { BitcodecItem, EncodingType, IBitcodec, NumberTypes } from \"./models\";\nimport { CAllBuffer, CArray, CBuffer, CNumber, CObject, CString, CVarArray, CVarBuffer, CVarString, CVarUIntBitcoin } from \"./lib\";\n\nconst bitcodec = {\n  AllBuffer: new CAllBuffer(),\n  Array: (length: number, anyCodec: IBitcodec<any>) => new CArray(length, anyCodec),\n  Buffer: (length: number) => new CBuffer(length),\n  Byte: new CNumber(NumberTypes.UInt8, 1),\n  Number: {\n    Int8: new CNumber(NumberTypes.Int8, 1),\n    UInt8: new CNumber(NumberTypes.UInt8, 1),\n    Int16BE: new CNumber(NumberTypes.Int16BE, 2),\n    Int16LE: new CNumber(NumberTypes.Int16LE, 2),\n    UInt16BE: new CNumber(NumberTypes.UInt16BE, 2),\n    UInt16LE: new CNumber(NumberTypes.UInt16LE, 2),\n    Int32BE: new CNumber(NumberTypes.Int32BE, 4),\n    Int32LE: new CNumber(NumberTypes.Int32LE, 4),\n    UInt32BE: new CNumber(NumberTypes.UInt32BE, 4),\n    UInt32LE: new CNumber(NumberTypes.UInt32LE, 4),\n    Int64BE: new CNumber(NumberTypes.Int64BE, 8),\n    Int64LE: new CNumber(NumberTypes.Int64LE, 8),\n    UInt64BE: new CNumber(NumberTypes.UInt64BE, 8),\n    UInt64LE: new CNumber(NumberTypes.UInt64LE, 8),\n    FloatBE: new CNumber(NumberTypes.FloatBE, 4),\n    FloatLE: new CNumber(NumberTypes.FloatLE, 4),\n    DoubleBE: new CNumber(NumberTypes.DoubleBE, 8),\n    DoubleLE: new CNumber(NumberTypes.DoubleLE, 8),\n  },\n  Object: (items: BitcodecItem[]) => new CObject(items),\n  String: (length: number, encodingType: EncodingType = \"utf8\") => new CString(length, encodingType),\n  VarArray: (lengthType: IBitcodec<any>, anyCodec: IBitcodec<any>) => new CVarArray(lengthType, anyCodec),\n  VarBuffer: (anyCodec: IBitcodec<any>) => new CVarBuffer(anyCodec),\n  VarString: (anyCodec: IBitcodec<any>, encodingType: EncodingType = \"utf8\") => new CVarString(anyCodec, encodingType),\n  VarUIntBitcoin: new CVarUIntBitcoin(),\n};\n\nexport default bitcodec;\nexport { IBitcodec };\nexport { hex2buffer, buffer2hex } from \"./util\";\n","import { TxSegwit, TxSegwitBase, TxSegwitBaseParsed } from \"./models/Tx\";\n\nexport const toTxSegwit = (txSegwitParsed: TxSegwitBaseParsed): TxSegwit => {\n  const txSegwit: TxSegwit = {\n    version: txSegwitParsed.version,\n    marker: txSegwitParsed.marker,\n    flag: txSegwitParsed.flag,\n    txIn: [],\n    txOut: txSegwitParsed.txOut,\n    lockTime: txSegwitParsed.lockTime,\n  };\n\n  txSegwitParsed.txIn.forEach((input, index) => {\n    txSegwit.txIn.push({\n      previousOutput: input.previousOutput,\n      signatureScript: input.signatureScript,\n      witnessScripts: txSegwitParsed.witnessScriptsArray[index],\n      sequence: input.sequence,\n    });\n  });\n\n  return txSegwit;\n};\n\nexport const toTxSegwitParsed = (txSegwit: TxSegwit): TxSegwitBaseParsed => {\n  const txSegwitParsed: TxSegwitBaseParsed = {\n    version: txSegwit.version,\n    marker: txSegwit.marker,\n    flag: txSegwit.flag,\n    txIn: [],\n    txOut: txSegwit.txOut,\n    witnessScriptsArray: [],\n    lockTime: txSegwit.lockTime,\n  };\n\n  txSegwit.txIn.forEach((input, index) => {\n    txSegwitParsed.txIn.push({\n      previousOutput: input.previousOutput,\n      signatureScript: input.signatureScript,\n      sequence: input.sequence,\n    });\n\n    txSegwitParsed.witnessScriptsArray.push(input.witnessScripts);\n  });\n\n  return txSegwitParsed;\n};\n\nexport const toTxSegwitBase = (txSegwit: TxSegwit, witnessLocktimeHex: string): TxSegwitBase => {\n  const txSegwitBase: TxSegwitBase = {\n    version: txSegwit.version,\n    marker: txSegwit.marker,\n    flag: txSegwit.flag,\n    txIn: [],\n    txOut: txSegwit.txOut,\n    witnessScripts_lockTime: witnessLocktimeHex,\n    lockTime: txSegwit.lockTime,\n  };\n\n  txSegwit.txIn.forEach((input, index) => {\n    txSegwitBase.txIn.push({\n      previousOutput: input.previousOutput,\n      signatureScript: input.signatureScript,\n      sequence: input.sequence,\n    });\n  });\n\n  return txSegwitBase;\n};\n","export * from \"./models\";\nexport { BlockHeaderCodec, BlockHeaderArrayCodec, BlockCodec } from \"./lib/codecs\";\nexport { TxCodec, TxArrayCodec } from \"./lib/TxCodec\";\n","import bitcodec, { IBitcodec, buffer2hex, hex2buffer } from \"@bitmatrix/bitcodec\";\nimport { toTxSegwit, toTxSegwitBase } from \"../converter\";\nimport { TxBase, TxSegwit, TxSegwitBase, TxSegwitBaseParsed } from \"../models/Tx\";\nimport { Tx, TxWitnessBase } from \"./codecs\";\nimport { WitnessLocktimeCodec } from \"./WitnessLocktimeCodec\";\n\nclass TxCodecClass implements IBitcodec<TxBase | TxSegwit> {\n  private length: number = 0;\n\n  encodeBytes: number = 0;\n  decodeBytes: number = 0;\n  encodingLength = (tx?: TxBase | TxSegwit): number => 0;\n\n  private isSegwit = (tx: TxBase | TxSegwit) => (<TxSegwit>tx).marker === 0 && (<TxSegwit>tx).flag === 1;\n  private isSegwitHex = (txHex: string) => txHex.substr(8, 4) === \"0001\";\n\n  constructor() {\n    this.encodingLength = (tx?: TxBase | TxSegwit) => {\n      if (tx === undefined) throw TypeError(\"Tx Codec: encodingLength tx is undefined.\");\n      if (this.isSegwit(tx)) return TxWitnessBase.encodingLength(tx);\n      return Tx.encodingLength(tx);\n    };\n  }\n\n  encode = (txObject: TxBase | TxSegwit, buffer?: Buffer, offset = 0): Buffer => {\n    const txObjectHex = hex2buffer(txObject);\n    const isTxBase = !this.isSegwit(txObject);\n\n    if (isTxBase) {\n      buffer = Tx.encode(txObjectHex, buffer, offset);\n      this.encodeBytes = Tx.encodeBytes;\n      return buffer;\n    }\n\n    // isSegwit\n    const witnessLocktimeCodec = new WitnessLocktimeCodec(txObject.txIn.length);\n    const witnessArray = (txObject as TxSegwit).txIn.map((txi) => txi.witnessScripts);\n    const witnessLocktimeHexBuffer = witnessLocktimeCodec.encode(\n      hex2buffer({ witnessScriptsArray: witnessArray, lockTime: txObject.lockTime } as { witnessScriptsArray: string[][]; lockTime: number })\n    );\n    const witnessLocktimeHex = buffer2hex(witnessLocktimeHexBuffer) as string;\n\n    const txSegwitBase: TxSegwitBase = toTxSegwitBase(txObject as TxSegwit, witnessLocktimeHex);\n    buffer = TxWitnessBase.encode(hex2buffer(txSegwitBase), buffer, offset);\n\n    this.encodeBytes = TxWitnessBase.encodeBytes;\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset = 0, end?: number): TxBase | TxSegwit => {\n    const txHex = buffer2hex(buffer.slice(offset, end));\n    const isTxBase = !this.isSegwitHex(txHex);\n\n    if (isTxBase) {\n      const objBuffer = Tx.decode(buffer, offset, end);\n      const txBase = buffer2hex(objBuffer) as TxBase;\n      this.decodeBytes = Tx.decodeBytes;\n      return txBase;\n    }\n\n    // isSegwit\n    const txWitnessBaseBuffer = TxWitnessBase.decode(buffer, offset, end);\n    const txWitnessBase = buffer2hex(txWitnessBaseBuffer) as TxSegwitBase;\n\n    const witnessLocktimeCodec = new WitnessLocktimeCodec(txWitnessBase.txIn.length);\n    const witnessLocktimeDataBuffer: { witnessScriptsArray: string[][]; lockTime: number } = witnessLocktimeCodec.decode(hex2buffer(txWitnessBase.witnessScripts_lockTime));\n    const witnessLocktimeData = buffer2hex(witnessLocktimeDataBuffer) as { witnessScriptsArray: string[][]; lockTime: number };\n    this.decodeBytes = witnessLocktimeCodec.decodeBytes;\n\n    const txSegwitParsed: TxSegwitBaseParsed = {\n      version: txWitnessBase.version,\n      marker: txWitnessBase.marker,\n      flag: txWitnessBase.flag,\n      txIn: txWitnessBase.txIn,\n      txOut: txWitnessBase.txOut,\n      witnessScriptsArray: witnessLocktimeData.witnessScriptsArray,\n      lockTime: witnessLocktimeData.lockTime,\n    };\n    const txSegwit = toTxSegwit(txSegwitParsed);\n\n    return txSegwit;\n  };\n}\n\nexport const TxCodec = new TxCodecClass();\nexport const TxArrayCodec = bitcodec.VarArray(bitcodec.VarUIntBitcoin, TxCodec);\n","import bitcodec, { IBitcodec, buffer2hex, hex2buffer } from \"@bitmatrix/bitcodec\";\n\nexport class WitnessLocktimeCodec implements IBitcodec<{ witnessScriptsArray: string[][]; lockTime: number }> {\n  private witnessLocktimeData = bitcodec.Object([\n    [\"witnessScriptsArray\", bitcodec.VarArray(bitcodec.VarUIntBitcoin, bitcodec.VarArray(bitcodec.VarUIntBitcoin, bitcodec.VarBuffer(bitcodec.VarUIntBitcoin)))],\n    [\"lockTime\", bitcodec.Number.UInt32LE],\n  ]);\n  private inputsCount;\n\n  encodeBytes: number;\n  decodeBytes: number;\n  encodingLength: (t?: any) => number;\n\n  constructor(inputsCount: number) {\n    this.inputsCount = inputsCount;\n    this.encodeBytes = this.witnessLocktimeData.encodeBytes;\n    this.decodeBytes = this.witnessLocktimeData.decodeBytes;\n    this.encodingLength = this.witnessLocktimeData.encodingLength;\n  }\n\n  encode = (value: any, buffer?: Buffer | undefined, offset?: number | undefined): Buffer => {\n    buffer = this.witnessLocktimeData.encode(value, buffer, offset).slice(1);\n    this.encodeBytes = this.witnessLocktimeData.encodeBytes;\n    return buffer;\n  };\n\n  decode = (buffer: Buffer, offset?: number | undefined, end?: number | undefined): { witnessScriptsArray: string[][]; lockTime: number } => {\n    const inputCountHex = this.inputsCount.toString(16).padStart(2, \"0\");\n    const bufferHex = buffer2hex(buffer);\n    const newBuffer = hex2buffer(inputCountHex + bufferHex);\n    const result = this.witnessLocktimeData.decode(newBuffer, offset, end);\n    this.decodeBytes = this.witnessLocktimeData.decodeBytes;\n    return result as { witnessScriptsArray: string[][]; lockTime: number };\n  };\n}\n","import bitcodec from \"@bitmatrix/bitcodec\";\nimport { TxCodec } from \"./TxCodec\";\n\n// tx\nconst txVersion = bitcodec.Number.UInt32LE; // uint32_t\nconst txInItemPreviousOutput = bitcodec.Object([\n  { name: \"hash\", type: bitcodec.Buffer(32) }, // char[32]\n  { name: \"index\", type: bitcodec.Number.UInt32LE }, // uint32_t\n]);\nconst txInItem = bitcodec.Object([\n  { name: \"previousOutput\", type: txInItemPreviousOutput },\n  { name: \"signatureScript\", type: bitcodec.VarBuffer(bitcodec.VarUIntBitcoin) }, // var_int, uchar[]\n  { name: \"sequence\", type: bitcodec.Number.UInt32LE }, // uint32_t\n]);\nconst txIn = bitcodec.VarArray(bitcodec.VarUIntBitcoin, txInItem);\nconst txOutItem = bitcodec.Object([\n  { name: \"value\", type: bitcodec.Number.Int64LE }, // int64_t\n  { name: \"pkScript\", type: bitcodec.VarBuffer(bitcodec.VarUIntBitcoin) }, // var_int, uchar[]\n]);\nconst txOut = bitcodec.VarArray(bitcodec.VarUIntBitcoin, txOutItem);\nconst txLockTime = bitcodec.Number.UInt32LE; // uint32_t\nexport const Tx = bitcodec.Object([\n  { name: \"version\", type: txVersion },\n  { name: \"txIn\", type: txIn }, // compactSize uint\n  { name: \"txOut\", type: txOut }, // compactSize uint\n  { name: \"lockTime\", type: txLockTime },\n]);\nexport const TxWitnessBase = bitcodec.Object([\n  { name: \"version\", type: txVersion },\n  { name: \"marker\", type: bitcodec.Byte }, // uint8_t\n  { name: \"flag\", type: bitcodec.Byte }, // uint8_t\n  { name: \"txIn\", type: txIn },\n  { name: \"txOut\", type: txOut },\n  { name: \"witnessScripts_lockTime\", type: bitcodec.AllBuffer },\n]);\n\n// block header\nexport const BlockHeaderCodec = bitcodec.Object([\n  [\"version\", bitcodec.Number.Int32LE], // uint32_t\n  [\"prevBlock\", bitcodec.Buffer(32)], // char[32]\n  [\"merkleRoot\", bitcodec.Buffer(32)], // char[32]\n  [\"timestamp\", bitcodec.Number.UInt32LE], // uint32_t\n  [\"bits\", bitcodec.Number.UInt32LE], // uint32_t\n  [\"nonce\", bitcodec.Number.UInt32LE], // uint32_t\n  [\"txnCount\", bitcodec.VarUIntBitcoin], // var_int - !!!bitcoin core (getblockheader hex-encoded data) doesn't provide this byte(s)!!!\n]);\nexport const BlockHeaderArrayCodec = bitcodec.VarArray(bitcodec.VarUIntBitcoin, BlockHeaderCodec);\n\n// block\nexport const BlockCodec = bitcodec.Object([\n  [\"version\", bitcodec.Number.Int32LE],\n  [\"prevBlock\", bitcodec.Buffer(32)],\n  [\"merkleRoot\", bitcodec.Buffer(32)],\n  [\"timestamp\", bitcodec.Number.UInt32LE],\n  [\"bits\", bitcodec.Number.UInt32LE],\n  [\"nonce\", bitcodec.Number.UInt32LE],\n  [\"txns\", bitcodec.VarArray(bitcodec.VarUIntBitcoin, TxCodec)],\n]);\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(607);\n"],"names":["Object","defineProperty","exports","value","toDouble","intHighLow","uintHighLow","onesComplement","assert","Int53Type","MAX_UINT32","test","message","Error","number","Math","floor","high","signbit","low","hl","signed","readInt53","writeInt53","common_1","enumerable","get","write_1","write","read_1","read","int53Type","buffer","offset","BE","endsWith","readUInt32BE","readUInt32LE","startsWith","writeUInt32BE","writeUInt32LE","checkLength","codecName","valueLength","codecLength","RangeError","checkBufferLengthForEncode","length","checkBufferLengthForDecode","end","checkDefined","type","TypeError","Buffer","isBuffer","t","typeError","rangeError","encodingLength","this","encodeBytes","decodeBytes","constructor","encode","from","copy","decode","slice","i","anyCodec","calcLength","items","util","calcAllLength","array","allocUnsafe","typeEncode","typeEncodeBytes","item","index","loffset","Array","typeDecode","typeDecodeBytes","numberType","prototype","r","map","isArray","name","o","reduce","previousValue","currentValue","object","start","bytes","forEach","result","bufferCodec","encodingType","CBuffer","byteLength","toString","lengthCodec","itemCodec","varBufferCodec","CVarBuffer","str","MAX_SAFE_INTEGER","checkUInt53","n","writeUInt8","writeUInt16LE","first","readUInt8","readUInt16LE","lo","CAllBuffer","CArray","CNumber","CObject","CString","CVarArray","CVarString","CVarUIntBitcoin","NumberTypes","Byte","Int8","UInt8","Int16BE","Int16LE","UInt16BE","UInt16LE","Int32BE","Int32LE","UInt32BE","UInt32LE","Int64BE","Int64LE","UInt64BE","UInt64LE","FloatBE","FloatLE","DoubleBE","DoubleLE","allOffset","lOffset","obj","newObj","k","hex2buffer","s","toLowerCase","buffer2hex","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","module","__webpack_modules__","call","bitcodec","AllBuffer","Number","String","VarArray","lengthType","VarBuffer","VarString","VarUIntBitcoin","e","toTxSegwit","txSegwitParsed","txSegwit","version","marker","flag","txIn","txOut","lockTime","input","push","previousOutput","signatureScript","witnessScripts","witnessScriptsArray","sequence","toTxSegwitParsed","toTxSegwitBase","witnessLocktimeHex","txSegwitBase","witnessScripts_lockTime","BlockHeaderCodec","BlockHeaderArrayCodec","BlockCodec","TxCodec","TxArrayCodec","tx","isSegwit","isSegwitHex","txHex","substr","undefined","TxWitnessBase","Tx","txObject","txObjectHex","witnessLocktimeCodec","WitnessLocktimeCodec","witnessArray","txi","witnessLocktimeHexBuffer","objBuffer","txBase","txWitnessBaseBuffer","txWitnessBase","witnessLocktimeDataBuffer","witnessLocktimeData","inputsCount","inputCountHex","padStart","bufferHex","newBuffer","txVersion","txInItemPreviousOutput","txInItem","txOutItem","txLockTime","__webpack_exports__"],"sourceRoot":""}